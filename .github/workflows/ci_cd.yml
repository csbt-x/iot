# Build, test and conditionally publish the manager docker image using the included gradle wrapper

name: CI/CD

on:
  # Push excluding tags and workflow changes
  push:
    branches:
        - '**'
    tags-ignore:
      - '*.*'
    paths-ignore:
      - '.github/**'
      - '.ci_cd/**'
      - '**/*.md'

  # When a release is published
  release:
    types: [published]

  workflow_dispatch:

env:
  PLATFORMS: linux/amd64,linux/aarch64
  
jobs:

  build:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
    
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.9.1
        with:
          access_token: ${{ github.token }}
          
      - name: Checkout
        uses: actions/checkout@v2
        
      - name: Make tag-cache dirs
        run: |
          chmod +x gradlew
          mkdir -p ~/manager-tags-old
          mkdir -p ~/manager-tags-new

      - name: Check ci_cd existence
        id: check_cicd_json
        uses: andstor/file-existence-action@v1
        with:
          files: ".ci_cd/ci_cd.json"

      - name: Get docker tags to monitor
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'workflow_dispatch' }}
        id: monitor-tags
        shell: python
          import json
          import os
          
          eventName = os.getenv('EVENT_NAME')
          refName = os.getenv('REF_NAME')
          pushTag = None
          deployTag = None
          deployEnvironment = None
          
          f = open(".ci_cd/ci_cd.json")
          data = json.load(f)
          f.close()
          
          managerPushConfig = data["managerDockerPush"]
          
          if managerPushConfig is not None:
            if len(managerPushConfig.keys()) > 0:
              for key in managerPushConfig.keys():
                # Output new tag cache files (for generating hash)
                print(f"Outputting manifest info for tag: {key}")
                os.system(f"docker manifest inspect openremote/manager:{key} > ~/manager-tags-new/{key}")
        
      - name: Load manager tag cache
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'workflow_dispatch' }}
        uses: actions/cache@v2
        id: manager-tag-cache
        with:
          path: |
            ~/manager-tags-old
          key: ${{ runner.os }}-manager-tags---${{ hashFiles('~/manager-tags-new/**') }}
          restore-keys: |
            ${{ runner.os }}-manager-tags---

      - name: Process ci_cd.json file
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' }}
        id: ci-cd-output
        shell: python
        run: |
          import json
          import os
          
          eventName = os.getenv('EVENT_NAME')
          refName = os.getenv('REF_NAME')
          deploys = []
          tags = None
          deployEnvironment = None
          
          f = open(".ci_cd/ci_cd.json")
          data = json.load(f)
          f.close()

          if eventName == "workflow_dispatch":
            eventName = "managerDockerPush"

          if data is not None and eventName in data:              
            eventConfig = data[eventName]
            
            if eventConfig is not None:
              if eventName == "managerDockerPush":
                # Iterate through keys and check if that manager docker image has changed since last execution
                for key in eventConfig.keys():
                  print(f"Checking manager docker tag: {key}")
                  newManifestStr = None
                  oldManifestStr = None

                  if os.path.exists(f"manager-tags-new/{key}"):
                    f = open(f"manager-tags-new/{key}")
                    newManifestStr = json.load(f)
                    f.close()
                  if os.path.exists(f"manager-tags-old/{key}"):
                    f = open(f"manager-tags-old/{key}")
                    oldManifestStr = json.load(f)
                    f.close()                  
                  
                  if newManifestStr != oldManifestStr: # Not a great way to compare but we'll assume manifest output is consistent
                    print(f"Manager docker tag '{key}' has been updated")
                    deployConfig = eventConfig[f'{key}.deploy']
                    if deployConfig is not None:
                      # Inject manager tag into deploy config (no point reacting to the manager image updating otherwise)
                      deployConfig['managerTag'] = key
                      deploys.append(deployConfig)
              
                # Clear eventConfig so not processed in next block
                eventConfig = None
                
              elif eventName == "push":
                eventConfig = eventConfig[refName]
                if eventConfig is not None:
                  deploys = eventConfig['deploy']
                  tags = eventConfig['distribute.tags']
            
              elif eventName == "release":
                eventConfig = eventConfig[refName]
                if eventConfig is not None:
                  deploys = eventConfig['deploy']
                  tags = eventConfig['distribute.tags']
             
                  if tags is not None:
                    tags = tags.replace("$version", refName)
                    print(f"Tags to push to docker: {tags}")
                    os.system(f"echo ::set-output name=tags::{tags}")
                  
                  deployStr = None
                  
                  if deploys is not None and isinstance(deploys, list) and len(deploys) > 0:
                    deployStr = ""
                    deployStr = ";".join(deploys.map(lambda d: d['environment'] + ":" + d['managerTag']))
                      
                  elif deploys is not None:
                    deployStr = deploys['environment'] + ":" + deploys['managerTag']
                    
                  if deployStr is not None and len(deployStr) > 0:
                    print(f"Deployments to deploy: {deployStr}")
                    os.system(f"echo ::set-output name=deploys::{deployStr}")
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}

      - name: Copy new tag cache to old
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'workflow_dispatch' }}
        run: cp -r ~/manager-tags-new/* ~/manager-tags-old/


#       - name: Set up JDK 17 and gradle cache
#         id: java
#         uses: actions/setup-java@v2
#         with:
#           distribution: 'temurin'
#           java-version: '17'
#           cache: 'gradle'
          
#       - name: Grant execute permission for gradlew and make image-cache
#         run: |
#           chmod +x gradlew
#           mkdir -p ~/image-cache

#       - name: Get yarn cache directory path
#         id: yarn-cache-dir-path
#         run: echo "::set-output name=dir::$(yarn config get cacheFolder)"

#       - name: Yarn cache
#         uses: actions/cache@v2
#         id: yarn-cache # use this to check for `cache-hit` (`steps.yarn-cache.outputs.cache-hit != 'true'`)
#         with:
#           path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
#           key: ${{ runner.os }}-yarn---${{ hashFiles('**/yarn.lock') }}
#           restore-keys: |
#             ${{ runner.os }}-yarn---
            
#       - name: Docker image cache
#         uses: actions/cache@v2
#         id: docker-cache
#         with:
#           path:  |
#             ~/image-cache
#           key: ${{ runner.os }}-docker---${{ hashFiles('profile/dev-testing.yml') }}
#           restore-keys: |
#             ${{ runner.os }}-docker---
          
      - name: Output build info
        run: |
          echo "************************************************************"
          echo "**************        BUILD INFO         *******************"
          echo "************************************************************"
          echo "Java version: $(java --version)"
          echo "Yarn version: $(yarn -v)"
          echo "Node version: $(node -v)"
          echo "Gradle cache: ${{ steps.java.outputs.cache-hit == 'true' }}"
          echo "Yarn cache: ${{ steps.yarn-cache.outputs.cache-hit == 'true' }}"
          echo "Docker cache: ${{ steps.docker-cache.outputs.cache-hit == 'true' }}"
          echo "Manager tag cache: ${{ steps.manager-tag-cache.outputs.cache-hit == 'true' }}"
          echo "Deploy environment: ${{ env.DEPLOY }}"
          echo "Push manager tags: ${{ steps.ci-cd-output.outputs.tags }}"
          echo "Deployments: ${{ steps.ci-cd-output.outputs.deploys }}"
          echo "************************************************************"
          echo "************************************************************"
          exit 1
          
      - name: Check for cached docker images
        id: check_docker
        uses: andstor/file-existence-action@v1
        with:
          files: ", ~/image-cache/postgres.tar.gz"
          
      - name: Load cached docker images
        if: steps.docker-cache.outputs.cache-hit == 'true'
        run: |
          docker load < ~/image-cache/keycloak.tar.gz
          docker load < ~/image-cache/postgres.tar.gz

      - name: Pull docker images
        if: steps.docker-cache.outputs.cache-hit != 'true'
        run: |
          docker-compose -f profile/dev-testing.yml pull
          keycloak=$(docker images --filter 'reference=openremote/keycloak' --format "{{.Repository}}:{{.Tag}}")
          postgres=$(docker images --filter 'reference=openremote/postgresql' --format "{{.Repository}}:{{.Tag}}")
          docker save $keycloak | gzip > ~/image-cache/keycloak.tar.gz
          docker save $postgres | gzip > ~/image-cache/postgres.tar.gz
          ls -R ~/image-cache

      - name: Start docker test services
        run: docker-compose -f profile/dev-testing.yml up -d --no-build
        
      - name: Run backend tests
        run: ./gradlew build
        timeout-minutes: 20
        continue-on-error: true
        
      - name: Prepare docker image
        if: ${{ needs.dockertag.outputs.tag != '' }}
        run: ./gradlew installDist
        timeout-minutes: 10
        
        ## TODO: Add UI tests to the pipeline
        # Start manager
        # Run UI tests with gradle

      - name: Share build artifacts
        if: ${{ needs.dockertag.outputs.tag != '' }}
        uses: actions/upload-artifact@v2
        with:
          name: dist-build
          path: |
            manager/build/install/manager
          retention-days: 1



  docker_image:
    name: Build & push docker image
    runs-on: ubuntu-latest
    needs: [build]
    if: ${{ needs.dockertag.outputs.tag != '' }}
    env:
      TAG: ${{ needs.dockertag.outputs.tag }}
    
    steps:
      - name: Login to DockerHub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Download build artifacts         
        uses: actions/download-artifact@v2
        with:
          name: dist-build
          path: manager/build/install/manager
          
      - name: set up QEMU
        uses: docker/setup-qemu-action@v1
        with:
          platforms: ${{ env.PLATFORMS }}

      - name: install buildx
        id: buildx
        uses: docker/setup-buildx-action@v1
        with:
          version: latest
          install: true

      - name: Build and push images
        run: |
          docker build --push --build-arg GIT_COMMIT=${{ github.sha }} --platform $PLATFORMS -t openremote/manager:$TAG manager/build/install/manager
