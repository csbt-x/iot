# Build, test and conditionally publish the manager docker image using the included gradle wrapper

name: CI/CD

on:
  # Push excluding tags and workflow changes
  push:
    branches:
        - '**'
    tags-ignore:
      - '*.*'
    paths-ignore:
      - '.github/**'
      - '.ci_cd/**'
      - '**/*.md'

  # When a release is published
  release:
    types: [published]

  workflow_dispatch:

env:
  PLATFORMS: linux/amd64,linux/aarch64
  
jobs:

  build:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
    
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.9.1
        with:
          access_token: ${{ github.token }}
          
      - name: Checkout
        uses: actions/checkout@v2
        
      - name: Make cache dirs and set file permissions
        run: |
          chmod +x gradlew
          mkdir -p ~/image-cache
          mkdir -p ~/manager-tags-old
          mkdir -p ~/manager-tags-new
          
      - name: Check if main repo
        id: is_main_repo
        run: |
          if [ $REPO_NAME == 'openremote/openremote' ]; then
            echo "::set-output name=value::true"
          fi
        env:
          REPO_NAME: ${{ github.repository }}
          
      - name: Check deployment dir
        id: check_deployment_dir
        uses: andstor/file-existence-action@v1
        with:
          files: "deployment"
          
      - name: Check deployment dockerfile
        id: check_deployment_dockerfile
        uses: andstor/file-existence-action@v1
        with:
          files: "deployment/Dockerfile"

      - name: Check custom project
        id: check_custom_project
        uses: andstor/file-existence-action@v1
        with:
          files: "openremote,.gitmodules"

      - name: Check ci_cd existence
        id: check_cicd_json
        uses: andstor/file-existence-action@v1
        with:
          files: ".ci_cd/ci_cd.json"

      - name: Get docker tags to monitor
        # TODO if: ${{ steps.is_main_repo.outputs.value != 'true' && steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'schedule' }}
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'workflow_dispatch' }}
        id: monitor-tags
        shell: python
        run: |
          import json
          import os
          
          eventName = os.getenv('EVENT_NAME')
          refName = os.getenv('REF_NAME')
          pushTag = None
          deployTag = None
          deployEnvironment = None
          
          f = open(".ci_cd/ci_cd.json")
          data = json.load(f)
          f.close()
          
          managerPushConfig = data["managerDockerPush"]
          
          if managerPushConfig is not None:
            if len(managerPushConfig.keys()) > 0:
              for key in managerPushConfig.keys():
                # Output new tag cache files (for generating hash)
                os.system(f"echo 'Outputting manifest info for tag: {key}'")
                os.system(f"docker manifest inspect openremote/manager:{key} > ~/manager-tags-new/{key}")
            os.system("echo 'Tag manifests generated:'")
            os.system("find ~/manager-tags-new")
        
        
      - name: Load manager tag cache
        if: ${{ steps.is_main_repo.outputs.value != 'true' && steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'workflow_dispatch' }}
        uses: actions/cache@v2
        id: manager-tag-cache
        with:
          path: |
            ~/manager-tags-old
          key: ${{ runner.os }}-manager-tags---${{ hashFiles('~/manager-tags-new/**') }}
          restore-keys: |
            ${{ runner.os }}-manager-tags---

      - name: Process ci_cd.json file
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' }}
        id: ci-cd-output
        shell: python
        run: |
          import json
          import os
          
          eventName = os.getenv('EVENT_NAME')
          refName = os.getenv('REF_NAME')
          isMainRepo = os.getenv('IS_MAIN_REPO')
          deploys = None
          tags = None
          deployEnvironment = None
          
          f = open(".ci_cd/ci_cd.json")
          data = json.load(f)
          f.close()

          if eventName == "workflow_dispatch":
            eventName = "managerDockerPush"

          if data is not None and eventName in data:              
            eventConfig = data[eventName]
            
            if eventConfig is not None:
            
              if eventName == "managerDockerPush":
              
                if isMainRepo == 'true':
                  os.system("echo 'Ignoring scheduled trigger as this is the main openremote repository'")
                  # TODO: exit(1)
              
                # Iterate through keys and check if that manager docker image has changed since last execution
                deploys=[]
                for key in eventConfig.keys():
                  os.system(f"echo 'Checking manager docker tag: {key}'")
                  newManifestStr = None
                  oldManifestStr = None

                  if os.path.exists(os.path.expanduser(f"~/manager-tags-new/{key}")):
                    f = open(os.path.expanduser(f"~/manager-tags-new/{key}"))
                    newManifestStr = f.read()
                    f.close()
                  if os.path.exists(os.path.expanduser(f"~/manager-tags-old/{key}")):
                    f = open(os.path.expanduser(f"~/manager-tags-old/{key}"))
                    oldManifestStr = f.read()
                    f.close()                  
                  
                  if newManifestStr != oldManifestStr: # Not a great way to compare but we'll assume manifest output is consistent
                    os.system(f"echo 'Manager docker tag has been updated: {key}'")
                    deployConfig = eventConfig[key]['deploy']
                    if deployConfig is not None:
                      # Inject manager tag into deploy config (no point reacting to the manager image updating otherwise)
                      deployConfig['managerTag'] = key
                      deploys.append(deployConfig)
                
              elif eventName == "push":
              
                eventConfig = eventConfig[refName]
                if eventConfig is not None:
                  deploys = eventConfig['deploy']
                  tags = eventConfig['distribute']['tags']
            
              elif eventName == "release":
              
                eventConfig = eventConfig[refName]
                if eventConfig is not None:
                  deploys = eventConfig['deploy']
                  tags = eventConfig['distribute']['tags']
             
          if tags is not None and isMainRepo == 'true':
            tags = tags.replace("$version", refName)
            os.system(f" echo 'Manager tags to push to docker: {tags}'")
            tags = " ".join(map(lambda t: f"-t openremote/manager:{tag.strip()}", tags.split(",")))
            os.system(f"echo ::set-output name=tags::{tags}")
                  
          deployStr = None
          if deploys is not None and isinstance(deploys, list):
            if len(deploys) > 0:
              deployStr = ";".join(map(lambda d: d['environment'] + ":" + (d['managerTag'] if d['managerTag'] is not None else '$ref'), deploys))

          elif deploys is not None:
            deployStr = deploys['environment'] + ":" + (deploys['managerTag'] if deploys['managerTag'] is not None else '$ref')

          if deployStr is not None and len(deployStr) > 0:
            print(f"Deployments to deploy: {deployStr}")
            os.system(f"echo ::set-output name=deploys::{deployStr}")
        env:
          IS_MAIN_REPO: ${{ steps.is_main_repo.outputs.value }}
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}

      - name: Copy new tag cache to old
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'workflow_dispatch' }}
        run: |
          cd ~/manager-tags-new
          cp -r . ~/manager-tags-old/
          

      - name: Define backend test command
        id: test-backend-command
        run: |
          if [ $EVENT_NAME == 'push' || $EVENT_NAME == 'release' ]; then
            echo "::set-output name=value::./gradlew -p test test"
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          
      - name: Define UI test command
        id: test-ui-command
        run: echo ""
               
      - name: Define manager docker build command
        id: manager-docker-command
        run: |
          if [ ! -z $MANAGER_TAGS || $DEPLOYMENTS == *"$ref"* || ! -z $TEST_UI_CMD ]; then
            if [ $IS_CUSTOM_PROJECT == 'true' ]; then
              buildPath="openremote/manager/build/install/manager"
              commitSha=$(cd openremote; git rev-parse --short HEAD; cd ..)
            else
              buildPath="manager/build/install/manager"
              commitSha=$(git rev-parse --short HEAD)
            fi
            command="docker build --load --build-arg GIT_COMMIT=$commitSha --platform linux/amd64,linux/aarch64 $MANAGER_TAGS $buildPath
            echo "::set-output name=value::$command"
          fi
        env:
          MANAGER_TAGS: ${{ steps.ci-cd-output.outputs.tags }}
          DEPLOYMENTS: ${{ steps.ci-cd-output.outputs.deploys }}
          IS_CUSTOM_PROJECT: ${{ steps.check_custom_project.outputs.files_exist }}
          TEST_UI_CMD: ${{ steps.test-ui-command.outputs.value }}
          
      - name: Define deployment docker build command
        id: deployment-docker-command
        run: |
          if [ ! -z $DEPLOYMENTS && $HAS_DEPLOYMENT_DOCKERFILE == 'true' ]; then
            buildPath="deployment/build"
            commitSha=$(git rev-parse HEAD)
            commitShaShort=$(git rev-parse --short HEAD)
            command="docker build --load --build-arg GIT_COMMIT=$commitSha --platform linux/amd64,linux/aarch64 -t openremote/deployment:$commitShaShort $buildPath
            echo "::set-output name=value::$command"
          fi
        env:
          DEPLOYMENTS: ${{ steps.ci-cd-output.outputs.deploys }}
          HAS_DEPLOYMENT_DOCKERFILE: ${{ steps.check_deployment_dockerfile.outputs.files_exists }}
          
      - name: Define installDist command
        id: install-command
        run: |
          if [ ! -z $MANAGER_DOCKER_CMD ]; then
            echo "::set-output name=value::./gradlew installDist"
          elif [ ! -z $DEPLOYMENT_DOCKER_CMD ]; then
            echo "::set-output name=value::./gradlew -p deployment installDist"
          fi
        env:
          MANAGER_DOCKER_CMD: ${{ steps.manager-docker-command.outputs.value }}
          DEPLOYMENT_DOCKER_CMD: ${{ steps.deployment-docker-command.outputs.value }}          
          
#       - name: Set up JDK 17 and gradle cache
#         id: java
#         uses: actions/setup-java@v2
#         with:
#           distribution: 'temurin'
#           java-version: '17'
#           cache: 'gradle'

#       - name: Get yarn cache directory path
#         id: yarn-cache-dir-path
#         run: echo "::set-output name=dir::$(yarn config get cacheFolder)"

#       - name: Yarn cache
#         uses: actions/cache@v2
#         id: yarn-cache # use this to check for `cache-hit` (`steps.yarn-cache.outputs.cache-hit != 'true'`)
#         with:
#           path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
#           key: ${{ runner.os }}-yarn---${{ hashFiles('**/yarn.lock') }}
#           restore-keys: |
#             ${{ runner.os }}-yarn---
            
#       - name: Docker image cache
#         uses: actions/cache@v2
#         id: docker-cache
#         with:
#           path:  |
#             ~/image-cache
#           key: ${{ runner.os }}-docker---${{ hashFiles('profile/dev-testing.yml') }}
#           restore-keys: |
#             ${{ runner.os }}-docker---
          
      - name: Output info
        run: |
          echo "************************************************************"
          echo "**************            INFO           *******************"
          echo "************************************************************"
          echo "Trigger event: ${{ github.event_name }}"
          echo "Is main repo: ${{ steps.is_main_repo.outputs.value == 'true' }}"
          echo "Has deployment dir: ${{ steps.check_deployment_dir.outputs.files_exists == 'true' }}"
          echo "Has deployment dockerfile: ${{ steps.check_deployment_dockerfile.outputs.files_exists == 'true' }}"
          echo "Is custom project: ${{ steps.check_custom_project.outputs.files_exists == 'true' }}"
          echo "Push manager tags: ${{ steps.ci-cd-output.outputs.tags }}"
          echo "Deployments: ${{ steps.ci-cd-output.outputs.deploys }}"
          echo "Test backend command: $${{ steps.test-backend-command.outputs.value }}"
          echo "Test UI command: $${{ steps.test-ui-command.outputs.value }}"
          echo "Manager docker build command: ${{ steps.manager-docker-command.outputs.value }}"
          echo "Deployment docker build command: ${{ steps.deployment-docker-command.outputs.value }}"
          echo "InstallDist command: ${{ steps.install-command.outputs.value }}"
          echo "Java version: $(java --version)"
          echo "Yarn version: $(yarn -v)"
          echo "Node version: $(node -v)"
          echo "Gradle cache: ${{ steps.java.outputs.cache-hit == 'true' }}"
          echo "Yarn cache: ${{ steps.yarn-cache.outputs.cache-hit == 'true' }}"
          echo "Docker cache: ${{ steps.docker-cache.outputs.cache-hit == 'true' }}"
          echo "Manager tag cache: ${{ steps.manager-tag-cache.outputs.cache-hit == 'true' }}"
          echo "************************************************************"
          echo "************************************************************"
          exit 1
          
      - name: Load cached docker images
        if: steps.docker-cache.outputs.cache-hit == 'true'
        run: |
          docker load < ~/image-cache/keycloak.tar.gz
          docker load < ~/image-cache/postgres.tar.gz

      - name: Pull docker images
        if: steps.docker-cache.outputs.cache-hit != 'true'
        run: |
          docker-compose -f profile/dev-testing.yml pull
          keycloak=$(docker images --filter 'reference=openremote/keycloak' --format "{{.Repository}}:{{.Tag}}")
          postgres=$(docker images --filter 'reference=openremote/postgresql' --format "{{.Repository}}:{{.Tag}}")
          docker save $keycloak | gzip > ~/image-cache/keycloak.tar.gz
          docker save $postgres | gzip > ~/image-cache/postgres.tar.gz
          ls -R ~/image-cache

      - name: Start docker test services
        run: docker-compose -f profile/dev-testing.yml up -d --no-build
        
      - name: Run backend tests
        run: ./gradlew build
        timeout-minutes: 20
        continue-on-error: true
        
      - name: Prepare docker image
        if: ${{ needs.dockertag.outputs.tag != '' }}
        run: ./gradlew installDist
        timeout-minutes: 10
        
        ## TODO: Add UI tests to the pipeline
        # Start manager
        # Run UI tests with gradle

      - name: Share build artifacts
        if: ${{ needs.dockertag.outputs.tag != '' }}
        uses: actions/upload-artifact@v2
        with:
          name: dist-build
          path: |
            manager/build/install/manager
          retention-days: 1



  docker_image:
    name: Build & push docker image
    runs-on: ubuntu-latest
    needs: [build]
    if: ${{ needs.dockertag.outputs.tag != '' }}
    env:
      TAG: ${{ needs.dockertag.outputs.tag }}
    
    steps:
      - name: Login to DockerHub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Download build artifacts         
        uses: actions/download-artifact@v2
        with:
          name: dist-build
          path: manager/build/install/manager
          
      - name: set up QEMU
        uses: docker/setup-qemu-action@v1
        with:
          platforms: ${{ env.PLATFORMS }}

      - name: install buildx
        id: buildx
        uses: docker/setup-buildx-action@v1
        with:
          version: latest
          install: true

      - name: Build and push images
        run: |
          docker build --push --build-arg GIT_COMMIT=${{ github.sha }} --platform $PLATFORMS -t openremote/manager:$TAG manager/build/install/manager
