# Build, test and conditionally publish the manager docker image using the included gradle wrapper

name: CI/CD

on:
  # Push excluding tags and workflow changes
  push:
    branches:
        - '**'
    tags-ignore:
      - '*.*'
    paths-ignore:
      - '.github/**'
      - '.ci_cd/**'
      - '**/*.md'

  # When a release is published
  release:
    types: [published]

#   schedule:
    

  workflow_dispatch:
    inputs:
      ENVIRONMENT:
        description: 'Environment to use (if any)'
      MANAGER_TAG:
        description: 'Manager docker tag to pull'
      CLEAN_INSTALL:
        description: 'Delete data before starting'
        type: boolean
      HOST:
        description: 'Host to deploy to'
      SSH_USER:
        description: 'SSH Username'
      SSH_PORT:
        description: 'SSH port'
      SSH_PASSWORD:
        description: 'SSH password'
      SETUP_ADMIN_PASSWORD:
        description: 'Admin password override'
      COMMIT:
        description: 'Repo branch or commit SHA to use'

env:
  PLATFORMS: linux/amd64,linux/aarch64
  
jobs:

  build:
    name: CI/CD
    runs-on: ubuntu-latest

    steps:
    
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.9.1
        with:
          access_token: ${{ github.token }}
          
      - name: Checkout
        uses: actions/checkout@v2
        with:
          # This will only be available when run by workflow_dispatch otherwise will checkout branch/commit that triggered the workflow
          ref: ${{ github.event.inputs.COMMIT }}
          submodules: recursive
        
      - name: Make cache dirs and set file permissions
        run: |
          chmod +x gradlew
          mkdir -p ~/image-cache
          mkdir -p ~/manager-tags-old
          mkdir -p ~/manager-tags-new

      - name: Check if main repo
        id: is_main_repo
        run: |
          if [ $REPO_NAME == 'openremote/openremote' ]; then
            echo "::set-output name=value::true"
          fi
        env:
          REPO_NAME: ${{ github.repository }}
          
      - name: Check deployment build.gradle
        id: check_deployment_gradle
        uses: andstor/file-existence-action@v1
        with:
          files: "deployment/build.gradle"
          
      - name: Check deployment dockerfile
        id: check_deployment_dockerfile
        uses: andstor/file-existence-action@v1
        with:
          files: "deployment/Dockerfile"

      - name: Check custom project
        id: check_custom_project
        uses: andstor/file-existence-action@v1
        with:
          files: "openremote,.gitmodules"

      - name: Check ci_cd existence
        id: check_cicd_json
        uses: andstor/file-existence-action@v1
        with:
          files: ".ci_cd/ci_cd.json"
          
      - name: Check is custom project when scheduled trigger
        if: ${{ github.event_name == 'schedule' }}
        run: |
          if [ "$IS_CUSTOM_PROJECT" != 'true' ]; then
            echo "Schedule can only be used on a custom project repo
            exit 1
          fi
        env:
          IS_CUSTOM_PROJECT: ${{ steps.check_custom_project.outputs.files_exists }}

      - name: Get docker tags to monitor
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'schedule' }}
        id: monitor-tags
        shell: python
        run: |
          import json
          import os
          
          eventName = os.getenv('EVENT_NAME')
          refName = os.getenv('REF_NAME')
          pushTag = None
          deployTag = None
          deployEnvironment = None
          
          f = open(".ci_cd/ci_cd.json")
          data = json.load(f)
          f.close()
          
          managerPushConfig = data["managerDockerPush"]
          
          if managerPushConfig is not None:
            if len(managerPushConfig.keys()) > 0:
              for key in managerPushConfig.keys():
                # Output new tag cache files (for generating hash)
                os.system(f"echo 'Outputting manifest info for tag: {key}'")
                os.system(f"docker manifest inspect openremote/manager:{key} > ~/manager-tags-new/{key}")
            os.system("echo 'Tag manifests generated:'")
            os.system("find ~/manager-tags-new")        
        
      - name: Load manager tag cache
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name == 'schedule' }}
        uses: actions/cache@v2
        id: manager-tag-cache
        with:
          path: |
            ~/manager-tags-old
          key: ${{ runner.os }}-manager-tags---${{ hashFiles('~/manager-tags-new/**') }}
          restore-keys: |
            ${{ runner.os }}-manager-tags---

      - name: Process ci_cd.json file
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' && github.event_name != 'workflow_dispatch' }}
        id: ci-cd-output
        shell: python
        run: |
          import json
          import os
          
          eventName = os.getenv('EVENT_NAME')
          refName = os.getenv('REF_NAME')
          isMainRepo = os.getenv('IS_MAIN_REPO')
          deploys = None
          tags = None
          deployEnvironment = None
          
          f = open(".ci_cd/ci_cd.json")
          data = json.load(f)
          f.close()

          if eventName == "workflow_dispatch":
            eventName = "managerDockerPush"

          if data is not None and eventName in data:              
            eventConfig = data[eventName]
           
            if eventName == "managerDockerPush":

              # Iterate through keys and check if that manager docker image has changed since last execution
              deploys=[]
              for key in eventConfig.keys():
                os.system(f"echo 'Checking manager docker tag: {key}'")
                newManifestStr = None
                oldManifestStr = None

                if os.path.exists(os.path.expanduser(f"~/manager-tags-new/{key}")):
                  f = open(os.path.expanduser(f"~/manager-tags-new/{key}"))
                  newManifestStr = f.read()
                  f.close()
                if os.path.exists(os.path.expanduser(f"~/manager-tags-old/{key}")):
                  f = open(os.path.expanduser(f"~/manager-tags-old/{key}"))
                  oldManifestStr = f.read()
                  f.close()                  

                if newManifestStr != oldManifestStr: # Not a great way to compare but we'll assume manifest output is consistent
                  os.system(f"echo 'Manager docker tag has been updated: {key}'")
                  deployConfig = eventConfig[key]['deploy']
                  if deployConfig is not None:
                    # Inject manager tag into deploy config (no point reacting to the manager image updating otherwise)
                    deployConfig['managerTag'] = key
                    deploys.append(deployConfig)
                
              elif eventName == "push" and refName in eventConfig:
              
                eventConfig = eventConfig[refName]
                if eventConfig is not None:
                  deploys = eventConfig['deploy']
                  tags = eventConfig['distribute']['tags']
            
              elif eventName == "release" && refName in eventConfig:
              
                eventConfig = eventConfig[refName]
                if eventConfig is not None:
                  deploys = eventConfig['deploy']
                  tags = eventConfig['distribute']['tags']
             
          if tags is not None and isMainRepo == 'true':
            tags = tags.replace("$version", refName)
            firstTag = tags.split(",")[0]
            os.system(f"echo ::set-output name=firstTag::{firstTag}")
            os.system(f" echo 'Manager tags to push to docker: {tags}'")
            tags = " ".join(map(lambda t: f"-t openremote/manager:{t.strip()}", tags.split(",")))
            os.system(f"echo ::set-output name=tags::{tags}")
                  
          deployStr = None
          if deploys is not None and isinstance(deploys, list):
            if len(deploys) > 0:
              deployStr = ";".join(map(lambda d: d['environment'] + ":" + (d['managerTag'] if managerTag in d else '$ref'), deploys))

          elif deploys is not None:
            deployStr = deploys['environment'] + ":" + (deploys['managerTag'] if deploys['managerTag'] is not None else '$ref')

          if deployStr is not None and len(deployStr) > 0:
            print(f"Deployments to deploy: {deployStr}")
            os.system(f"echo ::set-output name=deploys::{deployStr}")
        env:
          IS_MAIN_REPO: ${{ steps.is_main_repo.outputs.value }}
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}

      - name: Copy new tag cache to old
        if: ${{ steps.check_cicd_json.outputs.files_exists == 'true' }}
        run: |
          cd ~/manager-tags-new
          cp -r . ~/manager-tags-old/
          
      - name: Sanitize deployments value
        id: deployments
        run: |
          deployments=$DEPLOYMENTS
          
          if [ "$EVENT_NAME" == 'workflow_dispatch' ]; then
            tag="$INPUT_MANAGER_TAG"
            if [ -z "$INPUT_MANAGER_TAG" ]; then
              tag="$ref"
            fi
            deployments="$INPUT_ENVIRONMENT:$tag"
          fi
          echo "::set-output name=value::$deployments"
        env:
          EVENT_NAME: ${{ github.event_name }}
          DEPLOYMENTS: ${{ steps.ci-cd-output.outputs.deploys }}
          INPUT_ENVIRONMENT: ${{ github.event.inputs.ENVIRONMENT }}
          INPUT_MANAGER_TAG: ${{ github.event.inputs.MANAGER_TAG }}

      - name: Define backend test command
        id: test-backend-command
        if: ${{ github.event_name == 'push' || github.event_name == 'release' }}
        run: echo "::set-output name=value::./gradlew -p test test"
          
      - name: Define UI test command
        id: test-ui-command
        if: ${{ github.event_name == 'push' || github.event_name == 'release' }}
        run: echo ""
      
      - name: Define manager docker build command
        id: manager-docker-command
        shell: bash
        run: |
          if [ $IS_CUSTOM_PROJECT == 'true' ]; then
            buildPath="openremote/manager/build/install/manager"
            commitSha=$(cd openremote; git rev-parse HEAD; cd ..)
            commitShaShort=$(cd openremote; git rev-parse --short HEAD; cd ..)
          else
            buildPath="manager/build/install/manager"
            commitSha=$(git rev-parse HEAD)
            commitShaShort=$(git rev-parse --short HEAD)
          fi
            
          if [ ! -z "$MANAGER_TAGS" ] || [[ "$DEPLOYMENTS" == *"\$ref"* ]] || [ ! -z "$TEST_UI_CMD" ]; then
            
            if [ ! -z "$MANAGER_TAGS" ]; then
              command="docker build --push --build-arg GIT_COMMIT=$commitSha --platform linux/amd64,linux/aarch64 $MANAGER_TAGS $buildPath"
            else
              command="docker build --build-arg GIT_COMMIT=$commitSha --platform linux/amd64,linux/aarch64 openremote/manager:$commitShaShort $buildPath"
            fi
            echo "::set-output name=value::$command"
          fi
          echo "::set-output name=buildPath::$buildPath"
          echo "::set-output name=refTag::$commitShaShort"
        env:
          FIRST_MANAGER_TAG: ${{ steps.ci-cd-output.outputs.firstTag }}
          MANAGER_TAGS: ${{ steps.ci-cd-output.outputs.tags }}
          DEPLOYMENTS: ${{ steps.deployments.outputs.value }}
          IS_CUSTOM_PROJECT: ${{ steps.check_custom_project.outputs.files_exist }}
          TEST_UI_CMD: ${{ steps.test-ui-command.outputs.value }}
          
      - name: Define deployment docker build command
        id: deployment-docker-command
        shell: bash
        run: |
          if [ "$DEPLOYMENT_DOCKERFILE_EXISTS" == 'true' ] && [ ! -z "$DEPLOYMENTS" ]; then
            if [ "$DEPLOYMENT_GRADLE_EXISTS" != 'true' ]; then
              echo "Deployment must have a build.gradle file to prepare the deployment files in the deployment/build dir"
              exit 1
            fi
            buildPath="deployment/build"
            commitSha=$(git rev-parse HEAD)
            commitShaShort=$(git rev-parse --short HEAD)
            command="docker build --build-arg GIT_COMMIT=$commitSha --platform linux/amd64,linux/aarch64 -t openremote/deployment:$commitShaShort $buildPath"
            echo "::set-output name=value::$command"
            echo "::set-output name=buildPath::$buildPath"
            echo "::set-output name=refTag::$commitShaShort"
          fi
        env:
          DEPLOYMENTS: ${{ steps.deployments.outputs.value }}
          DEPLOYMENT_DOCKERFILE_EXISTS: ${{ steps.check_deployment_dockerfile.outputs.files_exists }}
          DEPLOYMENT_GRADLE_EXISTS: ${{ steps.check_deployment_gradle.outputs.files_exists }}
          
      - name: Define installDist command
        id: install-command
        shell: bash
        run: |
          if [ ! -z "$MANAGER_DOCKER_CMD" ]; then
            echo "::set-output name=value::./gradlew installDist"
          elif [ ! -z "$DEPLOYMENT_DOCKER_CMD" ]; then
            echo "::set-output name=value::./gradlew -p deployment installDist"
          fi
        env:
          MANAGER_DOCKER_CMD: ${{ steps.manager-docker-command.outputs.value }}
          DEPLOYMENT_DOCKER_CMD: ${{ steps.deployment-docker-command.outputs.value }}
          
      - name: Output info
        run: |
          echo "************************************************************"
          echo "**************            INFO           *******************"
          echo "************************************************************"
          echo "Trigger event: ${{ github.event_name }}"
          echo "Is main repo: ${{ steps.is_main_repo.outputs.value == 'true' }}"
          echo "Is custom project repo: ${{ steps.check_custom_project.outputs.files_exists == 'true' }}"
          echo "Has deployment dockerfile: ${{ steps.check_deployment_dockerfile.outputs.files_exists == 'true' }}"
          echo "Manager commit SHA: ${{ steps.manager-docker-command.outputs.refTag }}"
          echo "Deployment commit SHA: ${{ steps.deployment-docker-command.outputs.refTag }}"
          echo "Deployments: ${{ steps.deployments.outputs.value }}"
          echo "Test backend command: ${{ steps.test-backend-command.outputs.value }}"
          echo "Test UI command: ${{ steps.test-ui-command.outputs.value }}"
          echo "Manager docker build command: ${{ steps.manager-docker-command.outputs.value }}"
          echo "Deployment docker build command: ${{ steps.deployment-docker-command.outputs.value }}"
          echo "InstallDist command: ${{ steps.install-command.outputs.value }}"
          echo "Java version: $(java --version)"
          echo "Yarn version: $(yarn -v)"
          echo "Node version: $(node -v)"
          echo "Gradle cache: ${{ steps.java.outputs.cache-hit == 'true' }}"
          echo "Yarn cache: ${{ steps.yarn-cache.outputs.cache-hit == 'true' }}"
          echo "Docker cache: ${{ steps.docker-cache.outputs.cache-hit == 'true' }}"
          echo "Manager tag cache: ${{ steps.manager-tag-cache.outputs.cache-hit == 'true' }}"
          echo "************************************************************"
          echo "************************************************************"

      - name: Login to DockerHub
        if: ${{ steps.manager-docker-command.outputs.value != '' || steps.deployment-docker-command.outputs.value != '' }}
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
          
      - name: set up QEMU
        if: ${{ steps.manager-docker-command.outputs.value != '' || steps.deployment-docker-command.outputs.value != '' }}
        uses: docker/setup-qemu-action@v1
        with:
          platforms: linux/amd64,linux/aarch64

      - name: install buildx
        if: ${{ steps.manager-docker-command.outputs.value != '' || steps.deployment-docker-command.outputs.value != '' }}
        id: buildx
        uses: docker/setup-buildx-action@v1
        with:
          version: latest
          install: true

      - name: Set up JDK 17 and gradle cache
        id: java
        uses: actions/setup-java@v2
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'

      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn config get cacheFolder)"

      - name: Yarn cache
        uses: actions/cache@v2
        id: yarn-cache # use this to check for `cache-hit` (`steps.yarn-cache.outputs.cache-hit != 'true'`)
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn---${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn---
            
      - name: Docker image cache
        uses: actions/cache@v2
        if: steps.test-backend-command.outputs.value != ''
        id: docker-cache
        with:
          path:  |
            ~/image-cache
          key: ${{ runner.os }}-docker---${{ hashFiles('profile/dev-testing.yml') }}
          restore-keys: |
            ${{ runner.os }}-docker---

      - name: Load cached docker images
        if: steps.docker-cache.outputs.cache-hit == 'true'
        run: |
          docker load < ~/image-cache/keycloak.tar.gz
          docker load < ~/image-cache/postgres.tar.gz

      - name: Pull docker images
        if: ${{ steps.test-backend-command.outputs.value != '' && steps.docker-cache.outputs.cache-hit != 'true' }}
        run: |
          docker-compose -f profile/dev-testing.yml pull
          keycloak=$(docker images --filter 'reference=openremote/keycloak' --format "{{.Repository}}:{{.Tag}}")
          postgres=$(docker images --filter 'reference=openremote/postgresql' --format "{{.Repository}}:{{.Tag}}")
          docker save $keycloak | gzip > ~/image-cache/keycloak.tar.gz
          docker save $postgres | gzip > ~/image-cache/postgres.tar.gz
          ls -R ~/image-cache

      - name: Start docker test services
        if: steps.test-backend-command.outputs.value != ''
        run: docker-compose -f profile/dev-testing.yml up -d --no-build
        
      - name: Run backend tests
        if: steps.test-backend-command.outputs.value != ''
        run: echo "RE-ENABLE TESTS!"
#         run: ${{ steps.test-backend-command.outputs.value }}
        timeout-minutes: 20
        continue-on-error: true
        
      - name: Start docker frontend test services
        if: steps.test-ui-command.outputs.value != ''
        run: echo "START TEST UI SERVICES!!!! - Load manager image from cache etc."
        
      - name: Run frontend tests
        if: steps.test-ui-command.outputs.value != ''
        run: ${{ steps.test-ui-command.outputs.value }}
        timeout-minutes: 20
        continue-on-error: true

      - name: Run install dist
        if: steps.install-command.outputs.value != ''
        run: ${{ steps.install-command.outputs.value }}
        timeout-minutes: 10
        
      - name: Run manager docker command
        if: steps.manager-docker-command.outputs.value != ''
        run: |
          ${{ steps.manager-docker-command.outputs.value }}

      - name: Check deployment script
        if: steps.deployments.outputs.value != ''
        id: check_deployment_script
        uses: andstor/file-existence-action@v1
        with:
          files: ".ci_cd/deploy.sh"
          
      - name: Deployment script missing
        if: ${{ steps.deployments.outputs.value != '' && steps.check_deployment_script.outputs.files_exists != 'true' }}
        run: exit 1
        
      - name: Run deployment docker command
        if: steps.deployment-docker-command.outputs.value != ''
        run: |
          ${{ steps.deployment-docker-command.outputs.value }}

      - name: Do deployments
        if: steps.deployments.outputs.value != ''
        shell: python
        run: |
          
          import json
          import os
          import sys
          import subprocess
          
          deployments = os.getenv("DEPLOYMENTS")
          deployments = deployments.split(";")
          managerRef = os.getenv("MANAGER_REF")
          deploymentRef = os.getenv("DEPLOYMENT_REF")
          secrets = json.loads(os.getenv('SECRETS'))
          inputs = os.getenv('INPUTS')
          
          if inputs is not None and inputs != '':
            inputs = json.loads(inputs)
          
          failure = False
                    
          # Make deploy script executable
          os.system("chmod +x .ci_cd/deploy.sh")
          
          for deployment in deployments:
            dep = deployment.split(":")
            env = dep[0]
            managerTag = dep[1]
            managerTagFound = True
            
            os.putenv("MANAGER_TAG", managerTag)
            os.putenv("ENVIRONMENT", env)
                      
            # Clean stale ssh credentials and temp files
            os.system("rm ssh.env 2>/dev/null")
            os.system("rm ssh.key 2>/dev/null")
            os.system("rm -r temp 2>/dev/null")
            os.system("mkdir temp")
            
            # ------------------------------------------------------
            # Output env variables to temp env file for POSIX shell
            # ------------------------------------------------------
            
            # Output default values for environment variables
            os.system("echo 'SSH_PORT=\"22\"' >> temp/env")
            os.system("echo 'SSH_USER=\"root\"' >> temp/env")
            
            # Output env file if exists
            if os.path.exists(".ci_cd/env/.env"):
              os.system("cat .ci_cd/env/.env >> temp/env")
              
            # Output environment specific env file if exists
            if env is not None and env != '' and os.path.exists(f".ci_cd/env/{env}.env"):
              os.system(f"cat .ci_cd/env/{env}.env >> temp/env")
            
            # Output secrets (spacial handling for SSH_KEY and SSH_PASSWORD)
            # _ENV_ prefixed keys are output last (to override any non env specific keys)
            for key, value in secrets.items():
              if key.startswith("_"):
                continue
              os.system(f"echo 'Secret found {key}...'")
              if key == "SSH_KEY":
                os.system(f"echo \"{value}\" > ssh.key")
              elif key == "SSH_PASSWORD":
                os.system(f"echo '{key}=\"{value}\"' > ssh.env")
              else:
                lines = len(value.split("\n"))
                if lines > 1:
                    os.system(f"echo '{key}=\"' >> temp/env")
                    os.system(f"echo '{value}\"' >> temp/env")
                else:
                    os.system(f"echo '{key}=\"{value}\"' >> temp/env")

            for key, value in secrets.items():
              if not key.startswith("_"):
                continue
              environment = (env if env else "").upper()
              prefix = "_" + environment + "_"
              if not key.startswith(prefix):
                continue
              else:
                key = key.replace(prefix, "")
              os.system(f"echo 'Secret found {key}...'")
              if key == "SSH_KEY":
                os.system(f"echo \"{value}\" > ssh.key")
              elif key == "SSH_PASSWORD":
                os.system(f"echo '{key}=\"{value}\"' > ssh.env")
              else:
                lines = len(value.split("\n"))
                if lines > 1:
                    os.system(f"echo '{key}=\"' >> temp/env")
                    os.system(f"echo '{value}\"' >> temp/env")
                else:
                    os.system(f"echo '{key}=\"{value}\"' >> temp/env")


            # Output inputs that have a value
            if inputs is not None and inputs != '':
              for key, value in inputs.items():
                if value is not None and value != '':
                  os.system(f"echo 'Input found {key}...'")
                  os.system(f"echo '{key}=\"{value}\"' >> temp/env")
            
            # Execute deploy script            
            os.system(f"echo 'Executing deploy script for deployment: managerTag={managerTag} deploymentTag={deploymentRef} environment={env}'")
            result = subprocess.run("bash .ci_cd/deploy.sh", shell=True)
            
            if result.returncode != 0:
              os.system(f"echo 'Deployment failed: managerTag={managerTag} deploymentTag={deploymentRef} environment={env}'")
              failure = True
              continue
          
          if failure == True:
            os.system("echo 'One or more deployments failed'")
            sys.exit(1)
        env:
          REPO_NAME: ${{ github.repository }}
          DEPLOYMENTS: ${{ steps.deployments.outputs.value }}
          MANAGER_DOCKER_BUILD_PATH: ${{ steps.manager-docker-command.outputs.buildPath }}
          DEPLOYMENT_DOCKER_BUILD_PATH: ${{ steps.deployment-docker-command.outputs.buildPath }}
          MANAGER_REF: ${{ steps.manager-docker-command.outputs.refTag }}
          DEPLOYMENT_REF: ${{ steps.deployment-docker-command.outputs.refTag }}
          SECRETS: ${{ toJSON(secrets) }}
          INPUTS: ${{ toJSON(github.event.inputs) }}      
