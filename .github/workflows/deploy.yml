# Automatic or manual deployment of the stack using specified docker manager image tag from docker hub
# or alternatively a git commit can be sepcified to build a custom manager image for deployment

name: Deploy

on:
  # Manually request a deploy
  workflow_dispatch:
    inputs:
      host:
        description: 'Host to deploy to'
        required: true
      password:
        description: 'Admin password override'
      managerTag:
        description: 'Manager docker tag to pull'
      commit:
        description: 'Repo branch or commit SHA to use'
      environment:
        description: 'Environment to use (if any)'
      platform:
        description: 'Platform architecture'
        default: linux/amd64
      
        
  # Docker push webhook trigger
  repository_dispatch:
    types: [docker-push]

env:
  environment: staging

jobs:

  config:
    outputs:
      host: ${{ github.event.inputs.host }}
      password: ${{ steps.password.outputs.password }}
      managerTag: ${{ steps.manager-tag.outputs.managerTag }}
      commit: ${{ steps.commit.outputs.commit }}
      environment: ${{ steps.environment.outputs.value }}
      composeFile: ${{ env.COMPOSE_FILE }}
      customProject: ${{ steps.check_custom_project.outputs.files_exists }}
      buildManager: ${{ steps.manager-tag.outputs.managerTag == '' }}
      buildDeployment: ${{ steps.check_deployment_dir.outputs.files_exists }}
      platform: ${{ github.event.inputs.platform }}
    name: Evaluate inputs
    runs-on: ubuntu-latest
    
    steps:
      - name: Login to DockerHub
        if: github.event.inputs.managerTag != ''
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
          
      - name: Host input missing
        if: ${{ github.event.inputs.host == '' }}
        run: exit 1

      - name: Check commit input
        uses: actions/checkout@v2
        with:
          ref: ${{github.event.inputs.commit}}
        
      - name: Output commit input
        if: (github.event.inputs.commit != '') && (github.event.inputs.managerTag == '')
        id: commit
        run: echo "::set-output name=value::${{ github.event.inputs.commit }}"
        
      - name: Check manager tag input
        if: github.event.inputs.managerTag != ''
        id: manager-tag
        run: |
          docker manifest inspect openremote/manager:${{ github.event.inputs.managerTag }} > /dev/null 2> /dev/null
          echo "::set-output name=value::${{ github.event.inputs.managerTag }}"
        
      - name: Check environment input
        if: github.event.inputs.environment != ''
        id: environment
        run: echo "::set-output name=value::${{ github.event.inputs.environment }}"
        
      - name: Check environment compose file existence
        if: github.event.inputs.environment != ''
        id: check_env_compose
        uses: andstor/file-existence-action@v1
        with:
          files: "profile/${{github.event.inputs.environment}}.yml"
          
      - name: Environment compose file exists
        if: steps.check_env_compose.outputs.files_exists == 'true'
        run: echo "COMPOSE_FILE=$COMPOSE_FILE" >> $GITHUB_ENV
        env:
          COMPOSE_FILE: profile/${{github.event.inputs.environment}}.yml
      
      - name: Use default compose file
        if: steps.check_env_compose.outputs.files_exists != 'true'
        run: echo "COMPOSE_FILE=$COMPOSE_FILE" >> $GITHUB_ENV
        env:
          COMPOSE_FILE: docker-compose.yml
          
      - name: Check deployment existence
        id: check_deployment_dir
        uses: andstor/file-existence-action@v1
        with:
          files: "deployment/Dockerfile"          
          
      - name: Check custom project
        id: check_custom_project
        uses: andstor/file-existence-action@v1
        with:
          files: "openremote"

      - name: Output info
        run: |
          echo "************************************************************"
          echo "**************           INFO            *******************"
          echo "************************************************************"
          echo "Host: ${{ github.event.inputs.host }}"
          echo "environment: ${{ steps.environment.outputs.value }}"
          echo "Manager tag: ${{ steps.managerTag.outputs.value }}"
          echo "Repo commit: ${{ steps.commit.outputs.value }}"
          echo "Compose file: ${{ env.COMPOSE_FILE }}"
          echo "Custom project: ${{ steps.check_custom_project.outputs.files_exists }}"
          echo "Build manager: ${{ steps.manager-tag.outputs.managerTag == '' }}"
          echo "Build deployment: ${{ steps.check_deployment_dir.outputs.files_exists }}"
          echo "************************************************************"
          echo "************************************************************"
        
  build:
    name: Build code
    needs: [config]
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.config.outputs.environment }}
      
    env:
      PLATFORM: ${{ secrets.PLATFORM || needs.config.outputs.platform || linux/amd64 }}
    
    steps:

      - name: Checkout
        uses: actions/checkout@v2
        with:
          ref: ${{github.event.inputs.commit}}
          
      - name: Do Build
        if: ${{ needs.config.outputs.buildRequired == 'true' }}
        run: echo "DO INSTALL DIST!!!!!"
        #./gradlew installDist
          
      - name: set up QEMU
        uses: docker/setup-qemu-action@v1
        with:
          platforms: ${{ env.PLATFORM }}

      - name: install buildx
        id: buildx
        uses: docker/setup-buildx-action@v1
        with:
          version: latest
          install: true

      - name: Build manager image
        if: needs.config.outputs.buildManager == 'true'
        run: |
          docker build --platform $PLATFORM -t openremote/manager:$TAG manager/build/install/manager
        env:
          TAG:
        
      - name: Build manager image
        
        
        
        
  deploy:
    needs: [build]
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.config.outputs.environment }}
    
    steps:
         
      - name: Output secrets to .env file
        shell: bash
        run: |
          jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' <<< "$secrets" > .env
        env:
          secrets: ${{ toJson(secrets) }}

      - run: cat .env
